<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Utilities · RecipesPipeline.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">RecipesPipeline.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">RecipesPipeline.jl</a></li><li><span class="tocitem">Developer manual</span><ul><li><a class="tocitem" href="../../api/">Public API</a></li><li><a class="tocitem" href="../../recipes/">Recipes</a></li></ul></li><li><a class="tocitem" href="../../reference/">Reference</a></li><li><span class="tocitem">Source code</span><ul><li><a class="tocitem" href="../RecipesPipeline/">RecipesPipeline</a></li><li><a class="tocitem" href="../api/">API</a></li><li><a class="tocitem" href="../user_recipe/">User Recipes</a></li><li><a class="tocitem" href="../plot_recipe/">Plot Recipes</a></li><li><a class="tocitem" href="../type_recipe/">Type Recipes</a></li><li><a class="tocitem" href="../series_recipe/">Series Recipes</a></li><li><a class="tocitem" href="../group/">Grouping</a></li><li><a class="tocitem" href="../recipes/">Default recipes</a></li><li><a class="tocitem" href="../series/">Series handling</a></li><li><a class="tocitem" href="../group/">Grouping</a></li><li class="is-active"><a class="tocitem" href>Utilities</a><ul class="internal"><li><a class="tocitem" href="#DefaultsDict"><span>DefaultsDict</span></a></li><li><a class="tocitem" href="#D-types"><span>3D types</span></a></li><li><a class="tocitem" href="#Formatting"><span>Formatting</span></a></li><li><a class="tocitem" href="#D-seriestypes"><span>3D seriestypes</span></a></li><li><a class="tocitem" href="#Scales"><span>Scales</span></a></li><li><a class="tocitem" href="#Unzip"><span>Unzip</span></a></li><li><a class="tocitem" href="#Map-functions-on-vectors"><span>Map functions on vectors</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Source code</a></li><li class="is-active"><a href>Utilities</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Utilities</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaPlots/RecipesPipeline.jl/blob/master/docs/src/generated/utils.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h1><pre><code class="language-julia">const AVec = AbstractVector
const AMat = AbstractMatrix
const KW = Dict{Symbol, Any}
const AKW = AbstractDict{Symbol, Any}</code></pre><hr/><h2 id="DefaultsDict"><a class="docs-heading-anchor" href="#DefaultsDict">DefaultsDict</a><a id="DefaultsDict-1"></a><a class="docs-heading-anchor-permalink" href="#DefaultsDict" title="Permalink"></a></h2><hr/><pre><code class="language-julia">struct DefaultsDict &lt;: AbstractDict{Symbol, Any}
    explicit::KW
    defaults::KW
end

function Base.getindex(dd::DefaultsDict, k)
    return haskey(dd.explicit, k) ? dd.explicit[k] : dd.defaults[k]
end
Base.haskey(dd::DefaultsDict, k) = haskey(dd.explicit, k) || haskey(dd.defaults, k)
Base.get(dd::DefaultsDict, k, default) = haskey(dd, k) ? dd[k] : default
function Base.get!(dd::DefaultsDict, k, default)
    v = if haskey(dd, k)
        dd[k]
    else
        dd.defaults[k] = default
    end
    return v
end
function Base.delete!(dd::DefaultsDict, k)
    haskey(dd.explicit, k) &amp;&amp; delete!(dd.explicit, k)
    haskey(dd.defaults, k) &amp;&amp; delete!(dd.defaults, k)
end
Base.length(dd::DefaultsDict) = length(union(keys(dd.explicit), keys(dd.defaults)))
function Base.iterate(dd::DefaultsDict)
    exp_keys = keys(dd.explicit)
    def_keys = setdiff(keys(dd.defaults), exp_keys)
    key_list = collect(Iterators.flatten((exp_keys, def_keys)))
    iterate(dd, (key_list, 1))
end
function Base.iterate(dd::DefaultsDict, (key_list, i))
    i &gt; length(key_list) &amp;&amp; return nothing
    k = key_list[i]
    (k =&gt; dd[k], (key_list, i + 1))
end

Base.copy(dd::DefaultsDict) = DefaultsDict(copy(dd.explicit), dd.defaults)

RecipesBase.is_explicit(dd::DefaultsDict, k) = haskey(dd.explicit, k)
isdefault(dd::DefaultsDict, k) = !is_explicit(dd, k) &amp;&amp; haskey(dd.defaults, k)

Base.setindex!(dd::DefaultsDict, v, k) = dd.explicit[k] = v</code></pre><p>Reset to default value and return dict</p><pre><code class="language-julia">reset_kw!(dd::DefaultsDict, k) = is_explicit(dd, k) ? delete!(dd.explicit, k) : dd</code></pre><p>Reset to default value and return old value</p><pre><code class="language-julia">pop_kw!(dd::DefaultsDict, k) = is_explicit(dd, k) ? pop!(dd.explicit, k) : dd.defaults[k]
pop_kw!(dd::DefaultsDict, k, default) =
    is_explicit(dd, k) ? pop!(dd.explicit, k) : get(dd.defaults, k, default)</code></pre><p>Fallbacks for dicts without defaults</p><pre><code class="language-julia">reset_kw!(d::AKW, k) = delete!(d, k)
pop_kw!(d::AKW, k) = pop!(d, k)
pop_kw!(d::AKW, k, default) = pop!(d, k, default)</code></pre><hr/><h2 id="D-types"><a class="docs-heading-anchor" href="#D-types">3D types</a><a id="D-types-1"></a><a class="docs-heading-anchor-permalink" href="#D-types" title="Permalink"></a></h2><hr/><pre><code class="language-julia">abstract type AbstractSurface end

&quot;represents a contour or surface mesh&quot;
struct Surface{M &lt;: AMat} &lt;: AbstractSurface
    surf::M
end

Surface(f::Function, x, y) = Surface(Float64[f(xi, yi) for yi in y, xi in x])

Base.Array(surf::Surface) = surf.surf

for f in (:length, :size, :axes, :iterate)
    @eval Base.$f(surf::Surface, args...) = $f(surf.surf, args...)
end
Base.copy(surf::Surface) = Surface(copy(surf.surf))
Base.eltype(surf::Surface{T}) where {T} = eltype(T)


struct Volume{T}
    v::Array{T, 3}
    x_extents::Tuple{T, T}
    y_extents::Tuple{T, T}
    z_extents::Tuple{T, T}
end

default_extents(::Type{T}) where {T} = (zero(T), one(T))

function Volume(
    v::Array{T, 3},
    x_extents = default_extents(T),
    y_extents = default_extents(T),
    z_extents = default_extents(T),
) where {T}
    Volume(v, x_extents, y_extents, z_extents)
end

Base.Array(vol::Volume) = vol.v
for f in (:length, :size, :axes, :iterate)
    @eval Base.$f(vol::Volume, args...) = $f(vol.v, args...)
end
Base.copy(vol::Volume{T}) where {T} =
    Volume{T}(copy(vol.v), vol.x_extents, vol.y_extents, vol.z_extents)
Base.eltype(vol::Volume{T}) where {T} = T</code></pre><hr/><h2 id="Formatting"><a class="docs-heading-anchor" href="#Formatting">Formatting</a><a id="Formatting-1"></a><a class="docs-heading-anchor-permalink" href="#Formatting" title="Permalink"></a></h2><hr/><pre><code class="language-julia">&quot;Represents data values with formatting that should apply to the tick labels.&quot;
struct Formatted{T}
    data::T
    formatter::Function
end</code></pre><hr/><h2 id="D-seriestypes"><a class="docs-heading-anchor" href="#D-seriestypes">3D seriestypes</a><a id="D-seriestypes-1"></a><a class="docs-heading-anchor-permalink" href="#D-seriestypes" title="Permalink"></a></h2><hr/><p>TODO: Move to RecipesBase?</p><pre><code class="language-julia">&quot;&quot;&quot;
    is3d(::Type{Val{:myseriestype}})

Returns `true` if `myseriestype` represents a 3D series, `false` otherwise.
&quot;&quot;&quot;
is3d(st) = false
for st in (
    :contour,
    :contourf,
    :contour3d,
    :heatmap,
    :image,
    :path3d,
    :scatter3d,
    :surface,
    :volume,
    :wireframe,
    :mesh3d
)
    @eval is3d(::Type{Val{Symbol($(string(st)))}}) = true
end
is3d(st::Symbol) = is3d(Val{st})
is3d(plt, stv::AbstractArray) = all(st -&gt; is3d(plt, st), stv)
is3d(plotattributes::AbstractDict) = is3d(get(plotattributes, :seriestype, :path))


&quot;&quot;&quot;
    is_surface(::Type{Val{:myseriestype}})

Returns `true` if `myseriestype` represents a surface series, `false` otherwise.
&quot;&quot;&quot;
is_surface(st) = false
for st in (:contour, :contourf, :contour3d, :image, :heatmap, :surface, :wireframe)
    @eval is_surface(::Type{Val{Symbol($(string(st)))}}) = true
end
is_surface(st::Symbol) = is_surface(Val{st})
is_surface(plt, stv::AbstractArray) = all(st -&gt; is_surface(plt, st), stv)
is_surface(plotattributes::AbstractDict) =
    is_surface(get(plotattributes, :seriestype, :path))


&quot;&quot;&quot;
    needs_3d_axes(::Type{Val{:myseriestype}})

Returns `true` if `myseriestype` needs 3d axes, `false` otherwise.
&quot;&quot;&quot;
needs_3d_axes(st) = false
for st in (
    :contour3d,
    :path3d,
    :scatter3d,
    :surface,
    :volume,
    :wireframe,
)
    @eval needs_3d_axes(::Type{Val{Symbol($(string(st)))}}) = true
end
needs_3d_axes(st::Symbol) = needs_3d_axes(Val{st})
needs_3d_axes(plt, stv::AbstractArray) = all(st -&gt; needs_3d_axes(plt, st), stv)
needs_3d_axes(plotattributes::AbstractDict) =
    needs_3d_axes(get(plotattributes, :seriestype, :path))</code></pre><hr/><h2 id="Scales"><a class="docs-heading-anchor" href="#Scales">Scales</a><a id="Scales-1"></a><a class="docs-heading-anchor-permalink" href="#Scales" title="Permalink"></a></h2><hr/><pre><code class="language-julia">const SCALE_FUNCTIONS = Dict{Symbol, Function}(:log10 =&gt; NaNMath.log10, :log2 =&gt; NaNMath.log2, :ln =&gt; NaNMath.log)
const INVERSE_SCALE_FUNCTIONS =
    Dict{Symbol, Function}(:log10 =&gt; exp10, :log2 =&gt; exp2, :ln =&gt; exp)

scale_func(scale::Symbol) = x -&gt; get(SCALE_FUNCTIONS, scale, identity)(Float64(x))
inverse_scale_func(scale::Symbol) =
    x -&gt; get(INVERSE_SCALE_FUNCTIONS, scale, identity)(Float64(x))</code></pre><hr/><h2 id="Unzip"><a class="docs-heading-anchor" href="#Unzip">Unzip</a><a id="Unzip-1"></a><a class="docs-heading-anchor-permalink" href="#Unzip" title="Permalink"></a></h2><hr/><pre><code class="language-julia">for i in 2:4
    @eval begin
        unzip(v::AVec{&lt;:Tuple{Vararg{T, $i} where T}}) =
            $(Expr(:tuple, (:([t[$j] for t in v]) for j in 1:i)...))
    end
end</code></pre><hr/><h2 id="Map-functions-on-vectors"><a class="docs-heading-anchor" href="#Map-functions-on-vectors">Map functions on vectors</a><a id="Map-functions-on-vectors-1"></a><a class="docs-heading-anchor-permalink" href="#Map-functions-on-vectors" title="Permalink"></a></h2><hr/><pre><code class="language-julia">_map_funcs(f::Function, u::AVec) = map(f, u)
_map_funcs(fs::AVec{F}, u::AVec) where {F &lt;: Function} = [map(f, u) for f in fs]</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../group/">« Grouping</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 12 October 2020 12:15">Monday 12 October 2020</span>. Using Julia version 1.5.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
