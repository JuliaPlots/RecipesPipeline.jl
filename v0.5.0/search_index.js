var documenterSearchIndex = {"docs":
[{"location":"generated/RecipesPipeline/#RecipesPipeline","page":"RecipesPipeline","title":"RecipesPipeline","text":"","category":"section"},{"location":"generated/RecipesPipeline/","page":"RecipesPipeline","title":"RecipesPipeline","text":"module RecipesPipeline\n\nimport RecipesBase\nimport RecipesBase: @recipe, @series, RecipeData, is_explicit\nimport PlotUtils # tryrange and adapted_grid\nusing Dates\nusing NaNMath\n\nexport recipe_pipeline!","category":"page"},{"location":"generated/RecipesPipeline/","page":"RecipesPipeline","title":"RecipesPipeline","text":"Plots relies on these:","category":"page"},{"location":"generated/RecipesPipeline/","page":"RecipesPipeline","title":"RecipesPipeline","text":"export SliceIt,\n    DefaultsDict,\n    Formatted,\n    AbstractSurface,\n    Surface,\n    Volume,\n    is3d,\n    is_surface,\n    needs_3d_axes,\n    group_as_matrix,\n    reset_kw!,\n    pop_kw!,\n    scale_func,\n    inverse_scale_func,\n    unzip,\n    dateformatter,\n    datetimeformatter,\n    timeformatter","category":"page"},{"location":"generated/RecipesPipeline/","page":"RecipesPipeline","title":"RecipesPipeline","text":"API","category":"page"},{"location":"generated/RecipesPipeline/","page":"RecipesPipeline","title":"RecipesPipeline","text":"export warn_on_recipe_aliases,\n    splittable_attribute,\n    split_attribute,\n    process_userrecipe!,\n    get_axis_limits,\n    is_axis_attribute,\n    type_alias,\n    plot_setup!,\n    slice_series_attributes!,\n    process_sliced_series_attributes!\n\ninclude(\"utils.jl\")\ninclude(\"api.jl\")\ninclude(\"series.jl\")\ninclude(\"group.jl\")\ninclude(\"user_recipe.jl\")\ninclude(\"type_recipe.jl\")\ninclude(\"plot_recipe.jl\")\ninclude(\"series_recipe.jl\")\ninclude(\"recipes.jl\")\n\n\n\"\"\"\n    recipe_pipeline!(plt, plotattributes, args)\n\nRecursively apply user recipes, type recipes, plot recipes and series recipes to build a\nlist of `Dict`s, each corresponding to a series. At the beginning, `plotattributes`\ncontains only the keyword arguments passed in by the user. Then, add all series to the plot\nobject `plt` and return it.\n\"\"\"\nfunction recipe_pipeline!(plt, plotattributes, args)\n    @nospecialize\n    plotattributes[:plot_object] = plt","category":"page"},{"location":"generated/RecipesPipeline/","page":"RecipesPipeline","title":"RecipesPipeline","text":"","category":"page"},{"location":"generated/RecipesPipeline/#\"USER-RECIPES\"","page":"RecipesPipeline","title":"\"USER RECIPES\"","text":"","category":"section"},{"location":"generated/RecipesPipeline/","page":"RecipesPipeline","title":"RecipesPipeline","text":"process user and type recipes","category":"page"},{"location":"generated/RecipesPipeline/","page":"RecipesPipeline","title":"RecipesPipeline","text":"    kw_list = _process_userrecipes!(plt, plotattributes, args)","category":"page"},{"location":"generated/RecipesPipeline/","page":"RecipesPipeline","title":"RecipesPipeline","text":"","category":"page"},{"location":"generated/RecipesPipeline/#\"PLOT-RECIPES\"","page":"RecipesPipeline","title":"\"PLOT RECIPES\"","text":"","category":"section"},{"location":"generated/RecipesPipeline/","page":"RecipesPipeline","title":"RecipesPipeline","text":"The \"Plot recipe\" acts like a series type, and is processed before the plot layout is created, which allows for setting layouts and other plot-wide attributes. We get inputs which have been fully processed by \"user recipes\" and \"type recipes\", so we can expect standard vectors, surfaces, etc.  No defaults have been set yet.","category":"page"},{"location":"generated/RecipesPipeline/","page":"RecipesPipeline","title":"RecipesPipeline","text":"    kw_list = _process_plotrecipes!(plt, kw_list)","category":"page"},{"location":"generated/RecipesPipeline/","page":"RecipesPipeline","title":"RecipesPipeline","text":"","category":"page"},{"location":"generated/RecipesPipeline/#Plot/Subplot/Layout-setup","page":"RecipesPipeline","title":"Plot/Subplot/Layout setup","text":"","category":"section"},{"location":"generated/RecipesPipeline/","page":"RecipesPipeline","title":"RecipesPipeline","text":"    plot_setup!(plt, plotattributes, kw_list)","category":"page"},{"location":"generated/RecipesPipeline/","page":"RecipesPipeline","title":"RecipesPipeline","text":"At this point, kw_list is fully decomposed into individual series... one KW per series. The next step is to recursively apply series recipes until the backend supports that series type.","category":"page"},{"location":"generated/RecipesPipeline/","page":"RecipesPipeline","title":"RecipesPipeline","text":"","category":"page"},{"location":"generated/RecipesPipeline/#\"SERIES-RECIPES\"","page":"RecipesPipeline","title":"\"SERIES RECIPES\"","text":"","category":"section"},{"location":"generated/RecipesPipeline/","page":"RecipesPipeline","title":"RecipesPipeline","text":"    _process_seriesrecipes!(plt, kw_list)","category":"page"},{"location":"generated/RecipesPipeline/","page":"RecipesPipeline","title":"RecipesPipeline","text":"","category":"page"},{"location":"generated/RecipesPipeline/#Return-processed-plot-object","page":"RecipesPipeline","title":"Return processed plot object","text":"","category":"section"},{"location":"generated/RecipesPipeline/","page":"RecipesPipeline","title":"RecipesPipeline","text":"    return plt\nend\n\ninclude(\"precompile_includer.jl\")\n\nend","category":"page"},{"location":"generated/RecipesPipeline/","page":"RecipesPipeline","title":"RecipesPipeline","text":"","category":"page"},{"location":"generated/RecipesPipeline/","page":"RecipesPipeline","title":"RecipesPipeline","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/utils/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"generated/utils/","page":"Utilities","title":"Utilities","text":"const AVec = AbstractVector\nconst AMat = AbstractMatrix\nconst KW = Dict{Symbol, Any}\nconst AKW = AbstractDict{Symbol, Any}","category":"page"},{"location":"generated/utils/","page":"Utilities","title":"Utilities","text":"","category":"page"},{"location":"generated/utils/#DefaultsDict","page":"Utilities","title":"DefaultsDict","text":"","category":"section"},{"location":"generated/utils/","page":"Utilities","title":"Utilities","text":"","category":"page"},{"location":"generated/utils/","page":"Utilities","title":"Utilities","text":"struct DefaultsDict <: AbstractDict{Symbol, Any}\n    explicit::KW\n    defaults::KW\nend\n\nfunction Base.getindex(dd::DefaultsDict, k)\n    return haskey(dd.explicit, k) ? dd.explicit[k] : dd.defaults[k]\nend\nBase.haskey(dd::DefaultsDict, k) = haskey(dd.explicit, k) || haskey(dd.defaults, k)\nBase.get(dd::DefaultsDict, k, default) = haskey(dd, k) ? dd[k] : default\nfunction Base.get!(dd::DefaultsDict, k, default)\n    v = if haskey(dd, k)\n        dd[k]\n    else\n        dd.defaults[k] = default\n    end\n    return v\nend\nfunction Base.delete!(dd::DefaultsDict, k)\n    haskey(dd.explicit, k) && delete!(dd.explicit, k)\n    haskey(dd.defaults, k) && delete!(dd.defaults, k)\nend\nBase.length(dd::DefaultsDict) = length(union(keys(dd.explicit), keys(dd.defaults)))\nfunction Base.iterate(dd::DefaultsDict)\n    exp_keys = keys(dd.explicit)\n    def_keys = setdiff(keys(dd.defaults), exp_keys)\n    key_list = collect(Iterators.flatten((exp_keys, def_keys)))\n    iterate(dd, (key_list, 1))\nend\nfunction Base.iterate(dd::DefaultsDict, (key_list, i))\n    i > length(key_list) && return nothing\n    k = key_list[i]\n    (k => dd[k], (key_list, i + 1))\nend\n\nBase.copy(dd::DefaultsDict) = DefaultsDict(copy(dd.explicit), dd.defaults)\n\nRecipesBase.is_explicit(dd::DefaultsDict, k) = haskey(dd.explicit, k)\nisdefault(dd::DefaultsDict, k) = !is_explicit(dd, k) && haskey(dd.defaults, k)\n\nBase.setindex!(dd::DefaultsDict, v, k) = dd.explicit[k] = v","category":"page"},{"location":"generated/utils/","page":"Utilities","title":"Utilities","text":"Reset to default value and return dict","category":"page"},{"location":"generated/utils/","page":"Utilities","title":"Utilities","text":"reset_kw!(dd::DefaultsDict, k) = is_explicit(dd, k) ? delete!(dd.explicit, k) : dd","category":"page"},{"location":"generated/utils/","page":"Utilities","title":"Utilities","text":"Reset to default value and return old value","category":"page"},{"location":"generated/utils/","page":"Utilities","title":"Utilities","text":"pop_kw!(dd::DefaultsDict, k) = is_explicit(dd, k) ? pop!(dd.explicit, k) : dd.defaults[k]\npop_kw!(dd::DefaultsDict, k, default) =\n    is_explicit(dd, k) ? pop!(dd.explicit, k) : get(dd.defaults, k, default)","category":"page"},{"location":"generated/utils/","page":"Utilities","title":"Utilities","text":"Fallbacks for dicts without defaults","category":"page"},{"location":"generated/utils/","page":"Utilities","title":"Utilities","text":"reset_kw!(d::AKW, k) = delete!(d, k)\npop_kw!(d::AKW, k) = pop!(d, k)\npop_kw!(d::AKW, k, default) = pop!(d, k, default)","category":"page"},{"location":"generated/utils/","page":"Utilities","title":"Utilities","text":"","category":"page"},{"location":"generated/utils/#D-types","page":"Utilities","title":"3D types","text":"","category":"section"},{"location":"generated/utils/","page":"Utilities","title":"Utilities","text":"","category":"page"},{"location":"generated/utils/","page":"Utilities","title":"Utilities","text":"abstract type AbstractSurface end\n\n\"represents a contour or surface mesh\"\nstruct Surface{M <: AMat} <: AbstractSurface\n    surf::M\nend\n\nSurface(f::Function, x, y) = Surface(Float64[f(xi, yi) for yi in y, xi in x])\n\nBase.Array(surf::Surface) = surf.surf\n\nfor f in (:length, :size, :axes, :iterate)\n    @eval Base.$f(surf::Surface, args...) = $f(surf.surf, args...)\nend\nBase.copy(surf::Surface) = Surface(copy(surf.surf))\nBase.eltype(surf::Surface{T}) where {T} = eltype(T)\n\n\nstruct Volume{T}\n    v::Array{T, 3}\n    x_extents::Tuple{T, T}\n    y_extents::Tuple{T, T}\n    z_extents::Tuple{T, T}\nend\n\ndefault_extents(::Type{T}) where {T} = (zero(T), one(T))\n\nfunction Volume(\n    v::Array{T, 3},\n    x_extents = default_extents(T),\n    y_extents = default_extents(T),\n    z_extents = default_extents(T),\n) where {T}\n    Volume(v, x_extents, y_extents, z_extents)\nend\n\nBase.Array(vol::Volume) = vol.v\nfor f in (:length, :size, :axes, :iterate)\n    @eval Base.$f(vol::Volume, args...) = $f(vol.v, args...)\nend\nBase.copy(vol::Volume{T}) where {T} =\n    Volume{T}(copy(vol.v), vol.x_extents, vol.y_extents, vol.z_extents)\nBase.eltype(vol::Volume{T}) where {T} = T","category":"page"},{"location":"generated/utils/","page":"Utilities","title":"Utilities","text":"","category":"page"},{"location":"generated/utils/#Formatting","page":"Utilities","title":"Formatting","text":"","category":"section"},{"location":"generated/utils/","page":"Utilities","title":"Utilities","text":"","category":"page"},{"location":"generated/utils/","page":"Utilities","title":"Utilities","text":"\"Represents data values with formatting that should apply to the tick labels.\"\nstruct Formatted{T}\n    data::T\n    formatter::Function\nend","category":"page"},{"location":"generated/utils/","page":"Utilities","title":"Utilities","text":"","category":"page"},{"location":"generated/utils/#D-seriestypes","page":"Utilities","title":"3D seriestypes","text":"","category":"section"},{"location":"generated/utils/","page":"Utilities","title":"Utilities","text":"","category":"page"},{"location":"generated/utils/","page":"Utilities","title":"Utilities","text":"TODO: Move to RecipesBase?","category":"page"},{"location":"generated/utils/","page":"Utilities","title":"Utilities","text":"\"\"\"\n    is3d(::Type{Val{:myseriestype}})\n\nReturns `true` if `myseriestype` represents a 3D series, `false` otherwise.\n\"\"\"\nis3d(st) = false\nfor st in (\n    :contour,\n    :contourf,\n    :contour3d,\n    :heatmap,\n    :image,\n    :path3d,\n    :scatter3d,\n    :surface,\n    :volume,\n    :wireframe,\n    :mesh3d\n)\n    @eval is3d(::Type{Val{Symbol($(string(st)))}}) = true\nend\nis3d(st::Symbol) = is3d(Val{st})\nis3d(plt, stv::AbstractArray) = all(st -> is3d(plt, st), stv)\nis3d(plotattributes::AbstractDict) = is3d(get(plotattributes, :seriestype, :path))\n\n\n\"\"\"\n    is_surface(::Type{Val{:myseriestype}})\n\nReturns `true` if `myseriestype` represents a surface series, `false` otherwise.\n\"\"\"\nis_surface(st) = false\nfor st in (:contour, :contourf, :contour3d, :image, :heatmap, :surface, :wireframe)\n    @eval is_surface(::Type{Val{Symbol($(string(st)))}}) = true\nend\nis_surface(st::Symbol) = is_surface(Val{st})\nis_surface(plt, stv::AbstractArray) = all(st -> is_surface(plt, st), stv)\nis_surface(plotattributes::AbstractDict) =\n    is_surface(get(plotattributes, :seriestype, :path))\n\n\n\"\"\"\n    needs_3d_axes(::Type{Val{:myseriestype}})\n\nReturns `true` if `myseriestype` needs 3d axes, `false` otherwise.\n\"\"\"\nneeds_3d_axes(st) = false\nfor st in (\n    :contour3d,\n    :path3d,\n    :scatter3d,\n    :surface,\n    :volume,\n    :wireframe,\n    :mesh3d\n)\n    @eval needs_3d_axes(::Type{Val{Symbol($(string(st)))}}) = true\nend\nneeds_3d_axes(st::Symbol) = needs_3d_axes(Val{st})\nneeds_3d_axes(plt, stv::AbstractArray) = all(st -> needs_3d_axes(plt, st), stv)\nneeds_3d_axes(plotattributes::AbstractDict) =\n    needs_3d_axes(get(plotattributes, :seriestype, :path))","category":"page"},{"location":"generated/utils/","page":"Utilities","title":"Utilities","text":"","category":"page"},{"location":"generated/utils/#Scales","page":"Utilities","title":"Scales","text":"","category":"section"},{"location":"generated/utils/","page":"Utilities","title":"Utilities","text":"","category":"page"},{"location":"generated/utils/","page":"Utilities","title":"Utilities","text":"const SCALE_FUNCTIONS = Dict{Symbol, Function}(:log10 => NaNMath.log10, :log2 => NaNMath.log2, :ln => NaNMath.log)\nconst INVERSE_SCALE_FUNCTIONS =\n    Dict{Symbol, Function}(:log10 => exp10, :log2 => exp2, :ln => exp)\n\nscale_func(scale::Symbol) = x -> get(SCALE_FUNCTIONS, scale, identity)(Float64(x))\ninverse_scale_func(scale::Symbol) =\n    x -> get(INVERSE_SCALE_FUNCTIONS, scale, identity)(Float64(x))","category":"page"},{"location":"generated/utils/","page":"Utilities","title":"Utilities","text":"","category":"page"},{"location":"generated/utils/#Unzip","page":"Utilities","title":"Unzip","text":"","category":"section"},{"location":"generated/utils/","page":"Utilities","title":"Utilities","text":"","category":"page"},{"location":"generated/utils/","page":"Utilities","title":"Utilities","text":"unzip(v::AVec{<:Tuple}) = tuple((([t[j] for t in v]) for j in 1:length(v[1]))...)","category":"page"},{"location":"generated/utils/","page":"Utilities","title":"Utilities","text":"","category":"page"},{"location":"generated/utils/#Map-functions-on-vectors","page":"Utilities","title":"Map functions on vectors","text":"","category":"section"},{"location":"generated/utils/","page":"Utilities","title":"Utilities","text":"","category":"page"},{"location":"generated/utils/","page":"Utilities","title":"Utilities","text":"_map_funcs(f::Function, u::AVec) = map(f, u)\n_map_funcs(fs::AVec{F}, u::AVec) where {F <: Function} = [map(f, u) for f in fs]","category":"page"},{"location":"generated/utils/","page":"Utilities","title":"Utilities","text":"","category":"page"},{"location":"generated/utils/#Signature-strings","page":"Utilities","title":"Signature strings","text":"","category":"section"},{"location":"generated/utils/","page":"Utilities","title":"Utilities","text":"","category":"page"},{"location":"generated/utils/","page":"Utilities","title":"Utilities","text":"@nospecialize\n\nfunction userrecipe_signature_string(args)\n    return string(\"(::\", join(string.(typeof.(args)), \", ::\"), \")\")\nend\ntyperecipe_signature_string(::T) where T = \"(::Type{$T}, ::$T)\"\nplotrecipe_signature_string(st) = \"(::Type{Val{:$st}}, ::AbstractPlot)\"\nseriesrecipe_signature_string(st) = \"(::Type{Val{:$st}}, x, y, z)\"\n\n@specialize","category":"page"},{"location":"generated/utils/","page":"Utilities","title":"Utilities","text":"","category":"page"},{"location":"generated/utils/","page":"Utilities","title":"Utilities","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"generated/api/#Warnings","page":"API","title":"Warnings","text":"","category":"section"},{"location":"generated/api/","page":"API","title":"API","text":"\"\"\"\n    warn_on_recipe_aliases!(plt, plotattributes, recipe_type, args...)\n\nWarn if an alias is dedected in `plotattributes` after a recipe of type `recipe_type` is\napplied to 'args'. `recipe_type` is either `:user`, `:type`, `:plot` or `:series`.\n\"\"\"\nfunction warn_on_recipe_aliases!(plt, plotattributes::AKW, recipe_type::Symbol, @nospecialize(args)) end\nfunction warn_on_recipe_aliases!(plt, v::AbstractVector, recipe_type::Symbol, @nospecialize(args))\n    for x in v\n        warn_on_recipe_aliases!(plt, x, recipe_type, args)\n    end\nend\nfunction warn_on_recipe_aliases!(plt, rd::RecipeData, recipe_type::Symbol, @nospecialize(args))\n    warn_on_recipe_aliases!(plt, rd.plotattributes, recipe_type, args)\nend","category":"page"},{"location":"generated/api/#Grouping","page":"API","title":"Grouping","text":"","category":"section"},{"location":"generated/api/","page":"API","title":"API","text":"\"\"\"\n    splittable_attribute(plt, key, val, len)\n\nReturns `true` if the attribute `key` with the value `val` can be split into groups with\ngroup provided as a vector of length `len`, `false` otherwise.\n\"\"\"\nsplittable_attribute(plt, key, val, len) = false\nsplittable_attribute(plt, key, val::AbstractArray, len) =\n    !(key in (:group, :color_palette)) && length(axes(val, 1)) == len\nsplittable_attribute(plt, key, val::Tuple, len) =\n    all(v -> splittable_attribute(plt, key, v, len), val)\n\n\n\"\"\"\n    split_attribute(plt, key, val, indices)\n\nSelect the proper indices from `val` for attribute `key`.\n\"\"\"\nsplit_attribute(plt, key, val::AbstractArray, indices) =\n    val[indices, fill(Colon(), ndims(val) - 1)...]\nsplit_attribute(plt, key, val::Tuple, indices) =\n    Tuple(split_attribute(plt, key, v, indices) for v in val)","category":"page"},{"location":"generated/api/#Preprocessing-attributes","page":"API","title":"Preprocessing attributes","text":"","category":"section"},{"location":"generated/api/","page":"API","title":"API","text":"\"\"\"\n    preprocess_attributes!(plt, plotattributes)\n\nAny plotting package specific preprocessing of user or recipe input happens here.\nFor example, Plots replaces aliases and expands magic arguments.\n\"\"\"\nfunction preprocess_attributes!(plt, plotattributes) end","category":"page"},{"location":"generated/api/","page":"API","title":"API","text":"TODO: should the Plots version be defined as fallback in RecipesPipeline?","category":"page"},{"location":"generated/api/","page":"API","title":"API","text":"\"\"\"\n    is_subplot_attribute(plt, attr)\n\nReturns `true` if `attr` is a subplot attribute, otherwise `false`.\n\"\"\"\nis_subplot_attribute(plt, attr) = false","category":"page"},{"location":"generated/api/","page":"API","title":"API","text":"TODO: should the Plots version be defined as fallback in RecipesPipeline?","category":"page"},{"location":"generated/api/","page":"API","title":"API","text":"\"\"\"\n    is_axis_attribute(plt, attr)\n\nReturns `true` if `attr` is an axis attribute, i.e. it applies to `xattr`, `yattr` and\n`zattr`, otherwise `false`.\n\"\"\"\nis_axis_attribute(plt, attr) = false","category":"page"},{"location":"generated/api/#processing-of-axis-args","page":"API","title":"processing of axis args","text":"","category":"section"},{"location":"generated/api/","page":"API","title":"API","text":"axis args before type recipes should still be mapped to all axes","category":"page"},{"location":"generated/api/","page":"API","title":"API","text":"\"\"\"\n    preprocess_axis_args!(plt, plotattributes)\n\nPreprocessing of axis attributes.\nPrepends the axis letter to axis attributes by default.\n\"\"\"\nfunction preprocess_axis_args!(plt, plotattributes)\n    for (k, v) in plotattributes\n        if is_axis_attribute(plt, k)\n            pop!(plotattributes, k)\n            for l in (:x, :y, :z)\n                lk = Symbol(l, k)\n                haskey(plotattributes, lk) || (plotattributes[lk] = v)\n            end\n        end\n    end\nend\n\n\"\"\"\n    preprocess_axis_args!(plt, plotattributes, letter)\n\nThis version additionally stores the letter name in  `plotattributes[:letter]`.\n\"\"\"\nfunction preprocess_axis_args!(plt, plotattributes, letter)\n    plotattributes[:letter] = letter\n    preprocess_axis_args!(plt, plotattributes)\nend","category":"page"},{"location":"generated/api/","page":"API","title":"API","text":"axis args in type recipes should only be applied to the current axis","category":"page"},{"location":"generated/api/","page":"API","title":"API","text":"\"\"\"\n    postprocess_axis_args!(plt, plotattributes, letter)\n\nRemoves the `:letter` key from `plotattributes` and does the same prepending of the letters as `preprocess_axis_args!`.\n\"\"\"\nfunction postprocess_axis_args!(plt, plotattributes, letter)\n    pop!(plotattributes, :letter)\n    if letter in (:x, :y, :z)\n        for (k, v) in plotattributes\n            if is_axis_attribute(plt, k)\n                pop!(plotattributes, k)\n                lk = Symbol(letter, k)\n                haskey(plotattributes, lk) || (plotattributes[lk] = v)\n            end\n        end\n    end\nend","category":"page"},{"location":"generated/api/#User-recipes","page":"API","title":"User recipes","text":"","category":"section"},{"location":"generated/api/","page":"API","title":"API","text":"\"\"\"\n    process_userrecipe!(plt, attributes_list, attributes)\n\nDo plotting package specific post-processing and add series attributes to attributes_list.\nFor example, Plots increases the number of series in `plt`, sets `:series_plotindex` in\nattributes and possible adds new series attributes for errorbars or smooth.\n\"\"\"\nfunction process_userrecipe!(plt, attributes_list, attributes)\n    push!(attributes_list, attributes)\nend\n\n\"\"\"\n    get_axis_limits(plt, letter)\n\nGet the limits for the axis specified by `letter` (`:x`, `:y` or `:z`) in `plt`. If it\nerrors, `tryrange` from PlotUtils is used.\n\"\"\"\nget_axis_limits(plt, letter) = throw(ErrorException(\"Axis limits not defined.\"))","category":"page"},{"location":"generated/api/#Plot-recipes","page":"API","title":"Plot recipes","text":"","category":"section"},{"location":"generated/api/","page":"API","title":"API","text":"\"\"\"\n    type_alias(plt, st)\n\nReturn the seriestype alias for `st`.\n\"\"\"\ntype_alias(plt, st) = st","category":"page"},{"location":"generated/api/#Plot-setup","page":"API","title":"Plot setup","text":"","category":"section"},{"location":"generated/api/","page":"API","title":"API","text":"\"\"\"\n    plot_setup!(plt, plotattributes, kw_list)\n\nSetup plot, subplots and layouts.\nFor example, Plots creates the backend figure, initializes subplots, expands extrema and\nlinks subplot axes.\n\"\"\"\nfunction plot_setup!(plt, plotattributes, kw_list) end","category":"page"},{"location":"generated/api/#Series-recipes","page":"API","title":"Series recipes","text":"","category":"section"},{"location":"generated/api/","page":"API","title":"API","text":"\"\"\"\n    slice_series_attributes!(plt, kw_list, kw)\n\nFor attributes given as vector with one element per series, only select the value for\ncurrent series.\n\"\"\"\nfunction slice_series_attributes!(plt, kw_list, kw) end\n\n\"\"\"\n    process_sliced_series_attributes!(plt, kw_list)\n\nAll series attributes are now properly resolved. Any change of the `kw_list` before the application of recipes must come here.\n\"\"\"\nfunction process_sliced_series_attributes!(plt, kw_list) end\n\n\"\"\"\n    series_defaults(plt)\n\nReturns a `Dict` storing the defaults for series attributes.\n\"\"\"\nseries_defaults(plt) = Dict{Symbol, Any}()","category":"page"},{"location":"generated/api/","page":"API","title":"API","text":"TODO: Add a more sensible fallback including e.g. path, scatter, ...","category":"page"},{"location":"generated/api/","page":"API","title":"API","text":"\"\"\"\n    is_seriestype_supported(plt, st)\n\nCheck if the plotting package natively supports the seriestype `st`.\n\"\"\"\nis_seriestype_supported(plt, st) = false\n\n\"\"\"\n    is_key_supported(key)\n\nCheck if the plotting package natively supports the attribute `key`\n\"\"\"\nRecipesBase.is_key_supported(key) = true","category":"page"},{"location":"generated/api/#Finalizer","page":"API","title":"Finalizer","text":"","category":"section"},{"location":"generated/api/","page":"API","title":"API","text":"\"\"\"\n    add_series!(plt, kw)\n\nAdds the series defined by `kw` to the plot object.\nFor example Plots updates the current subplot arguments, expands extrema and pushes the\nthe series to the series_list of `plt`.\n\"\"\"\nfunction add_series!(plt, kw) end","category":"page"},{"location":"generated/api/","page":"API","title":"API","text":"","category":"page"},{"location":"generated/api/","page":"API","title":"API","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/precompile_includer/","page":"-","title":"-","text":"should_precompile = true","category":"page"},{"location":"generated/precompile_includer/","page":"-","title":"-","text":"Don't edit the following! Instead change the script for snoop_bot.","category":"page"},{"location":"generated/precompile_includer/","page":"-","title":"-","text":"ismultios = false\nismultiversion = false","category":"page"},{"location":"generated/precompile_includer/","page":"-","title":"-","text":"precompile_enclosure","category":"page"},{"location":"generated/precompile_includer/","page":"-","title":"-","text":"@static if !should_precompile","category":"page"},{"location":"generated/precompile_includer/","page":"-","title":"-","text":"nothing","category":"page"},{"location":"generated/precompile_includer/","page":"-","title":"-","text":"elseif !ismultios && !ismultiversion\n    @static if isfile(joinpath(\n        @__DIR__,\n        \"../deps/SnoopCompile/precompile/precompile_RecipesPipeline.jl\",\n    ))\n        include(\"../deps/SnoopCompile/precompile/precompile_RecipesPipeline.jl\")\n        _precompile_()\n    end\nelse\n\nend # precompile_enclosure","category":"page"},{"location":"generated/precompile_includer/","page":"-","title":"-","text":"","category":"page"},{"location":"generated/precompile_includer/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/series/#Series-handling","page":"Series handling","title":"Series handling","text":"","category":"section"},{"location":"generated/series/","page":"Series handling","title":"Series handling","text":"const FuncOrFuncs{F} = Union{F, Vector{F}, Matrix{F}}\nconst MaybeNumber = Union{Number, Missing}\nconst MaybeString = Union{AbstractString, Missing}\nconst DataPoint = Union{MaybeNumber, MaybeString}\n\n_prepare_series_data(x) = error(\"Cannot convert $(typeof(x)) to series data for plotting\")\n_prepare_series_data(::Nothing) = nothing\n_prepare_series_data(t::Tuple{T, T}) where {T <: Number} = t\n_prepare_series_data(f::Function) = f\n_prepare_series_data(ar::AbstractRange{<:Number}) = ar\nfunction _prepare_series_data(a::AbstractArray{<:MaybeNumber})\n    f = isimmutable(a) ? replace : replace!\n    a = f(x -> ismissing(x) || isinf(x) ? NaN : x, map(float, a))\nend\n_prepare_series_data(a::AbstractArray{<:Missing}) = fill(NaN, axes(a))\n_prepare_series_data(a::AbstractArray{<:MaybeString}) =\n    replace(x -> ismissing(x) ? \"\" : x, a)\n_prepare_series_data(s::Surface{<:AMat{<:MaybeNumber}}) =\n    Surface(_prepare_series_data(s.surf))\n_prepare_series_data(s::Surface) = s  # non-numeric Surface, such as an image\n_prepare_series_data(v::Volume) =\n    Volume(_prepare_series_data(v.v), v.x_extents, v.y_extents, v.z_extents)","category":"page"},{"location":"generated/series/","page":"Series handling","title":"Series handling","text":"default: assume x represents a single series","category":"page"},{"location":"generated/series/","page":"Series handling","title":"Series handling","text":"_series_data_vector(x, plotattributes) = [_prepare_series_data(x)]","category":"page"},{"location":"generated/series/","page":"Series handling","title":"Series handling","text":"fixed number of blank series","category":"page"},{"location":"generated/series/","page":"Series handling","title":"Series handling","text":"_series_data_vector(n::Integer, plotattributes) = [zeros(0) for i in 1:n]","category":"page"},{"location":"generated/series/","page":"Series handling","title":"Series handling","text":"vector of data points is a single series","category":"page"},{"location":"generated/series/","page":"Series handling","title":"Series handling","text":"_series_data_vector(v::AVec{<:DataPoint}, plotattributes) = [_prepare_series_data(v)]","category":"page"},{"location":"generated/series/","page":"Series handling","title":"Series handling","text":"list of things (maybe other vectors, functions, or something else)","category":"page"},{"location":"generated/series/","page":"Series handling","title":"Series handling","text":"function _series_data_vector(v::AVec, plotattributes)\n    if all(x -> x isa MaybeNumber, v)\n        _series_data_vector(Vector{MaybeNumber}(v), plotattributes)\n    elseif all(x -> x isa MaybeString, v)\n        _series_data_vector(Vector{MaybeString}(v), plotattributes)\n    else\n        vcat((_series_data_vector(vi, plotattributes) for vi in v)...)\n    end\nend","category":"page"},{"location":"generated/series/","page":"Series handling","title":"Series handling","text":"Matrix is split into columns","category":"page"},{"location":"generated/series/","page":"Series handling","title":"Series handling","text":"function _series_data_vector(v::AMat{<:DataPoint}, plotattributes)\n    if is3d(plotattributes)\n        [_prepare_series_data(Surface(v))]\n    else\n        [_prepare_series_data(v[:, i]) for i in axes(v, 2)]\n    end\nend","category":"page"},{"location":"generated/series/","page":"Series handling","title":"Series handling","text":"","category":"page"},{"location":"generated/series/","page":"Series handling","title":"Series handling","text":"_compute_x(x::Nothing, y::Nothing, z) = axes(z, 1)\n_compute_x(x::Nothing, y, z) = axes(y, 1)\n_compute_x(x::Function, y, z) = map(x, y)\n_compute_x(x, y, z) = x\n\n_compute_y(x::Nothing, y::Nothing, z) = axes(z, 2)\n_compute_y(x, y::Function, z) = map(y, x)\n_compute_y(x, y, z) = y\n\n_compute_z(x, y, z::Function) = map(z, x, y)\n_compute_z(x, y, z::AbstractMatrix) = Surface(z)\n_compute_z(x, y, z::Nothing) = nothing\n_compute_z(x, y, z) = z\n\n_nobigs(v::AVec{BigFloat}) = map(Float64, v)\n_nobigs(v::AVec{BigInt}) = map(Int64, v)\n_nobigs(v) = v\n\n@noinline function _compute_xyz(x, y, z, nice_error=false)\n    x = _compute_x(x, y, z)\n    y = _compute_y(x, y, z)\n    z = _compute_z(x, y, z)\n    if nice_error && isnothing(z) # don't touch 3D plots\n        n = size(x,1)\n        !isnothing(y) && size(y,1) != n && error(\"Expects $n elements in each col of y, found $(size(y,1)).\")\n    end\n    _nobigs(x), _nobigs(y), _nobigs(z)\nend","category":"page"},{"location":"generated/series/","page":"Series handling","title":"Series handling","text":"not allowed","category":"page"},{"location":"generated/series/","page":"Series handling","title":"Series handling","text":"_compute_xyz(x::Nothing, y::FuncOrFuncs{F}, z) where {F <: Function} =\n    error(\"If you want to plot the function `$y`, you need to define the x values!\")\n_compute_xyz(x::Nothing, y::Nothing, z::FuncOrFuncs{F}) where {F <: Function} =\n    error(\"If you want to plot the function `$z`, you need to define x and y values!\")\n_compute_xyz(x::Nothing, y::Nothing, z::Nothing) = error(\"x/y/z are all nothing!\")","category":"page"},{"location":"generated/series/","page":"Series handling","title":"Series handling","text":"","category":"page"},{"location":"generated/series/","page":"Series handling","title":"Series handling","text":"we are going to build recipes to do the processing and splitting of the args","category":"page"},{"location":"generated/series/","page":"Series handling","title":"Series handling","text":"","category":"page"},{"location":"generated/series/#The-catch-all-SliceIt-recipe","page":"Series handling","title":"The catch-all SliceIt recipe","text":"","category":"section"},{"location":"generated/series/","page":"Series handling","title":"Series handling","text":"ensure we dispatch to the slicer","category":"page"},{"location":"generated/series/","page":"Series handling","title":"Series handling","text":"struct SliceIt end","category":"page"},{"location":"generated/series/","page":"Series handling","title":"Series handling","text":"The SliceIt recipe finishes user and type recipe processing. It splits processed data into individual series data, stores in copied plotattributes for each series and returns no arguments.","category":"page"},{"location":"generated/series/","page":"Series handling","title":"Series handling","text":"@recipe function f(::Type{SliceIt}, x, y, z)\n    @nospecialize\n    nice_error = (x isa AbstractVector) && (y isa AbstractMatrix) # only check in the trivial case","category":"page"},{"location":"generated/series/","page":"Series handling","title":"Series handling","text":"handle data with formatting attached","category":"page"},{"location":"generated/series/","page":"Series handling","title":"Series handling","text":"    if typeof(x) <: Formatted\n        xformatter := x.formatter\n        x = x.data\n    end\n    if typeof(y) <: Formatted\n        yformatter := y.formatter\n        y = y.data\n    end\n    if typeof(z) <: Formatted\n        zformatter := z.formatter\n        z = z.data\n    end\n\n    xs = _series_data_vector(x, plotattributes)\n    ys = _series_data_vector(y, plotattributes)\n    zs = _series_data_vector(z, plotattributes)\n\n\n    mx = length(xs)\n    my = length(ys)\n    mz = length(zs)\n    if mx > 0 && my > 0 && mz > 0\n        for i in 1:max(mx, my, mz)","category":"page"},{"location":"generated/series/","page":"Series handling","title":"Series handling","text":"add a new series","category":"page"},{"location":"generated/series/","page":"Series handling","title":"Series handling","text":"            di = copy(plotattributes)\n            xi, yi, zi = xs[mod1(i, mx)], ys[mod1(i, my)], zs[mod1(i, mz)]\n            di[:x], di[:y], di[:z] = _compute_xyz(xi, yi, zi, nice_error)\n\n            push!(series_list, RecipeData(di, ()))\n        end\n    end\n    nothing  # don't add a series for the main block\nend","category":"page"},{"location":"generated/series/","page":"Series handling","title":"Series handling","text":"","category":"page"},{"location":"generated/series/","page":"Series handling","title":"Series handling","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/recipes/#Default-recipes","page":"Default recipes","title":"Default recipes","text":"","category":"section"},{"location":"generated/recipes/#Includes-stuff-from-Base/stdlib.","page":"Default recipes","title":"Includes stuff from Base/stdlib.","text":"","category":"section"},{"location":"generated/recipes/#Dates-and-Times","page":"Default recipes","title":"Dates & Times","text":"","category":"section"},{"location":"generated/recipes/","page":"Default recipes","title":"Default recipes","text":"dateformatter(dt) = string(Date(Dates.UTD(dt)))\ndatetimeformatter(dt) = string(DateTime(Dates.UTM(dt)))\ntimeformatter(t) = string(Dates.Time(Dates.Nanosecond(round(t))))\n\n@recipe f(::Type{Date}, dt::Date) = (dt -> Dates.value(dt), dateformatter)\n@recipe f(::Type{DateTime}, dt::DateTime) =\n    (dt -> Dates.value(dt), datetimeformatter)\n@recipe f(::Type{Dates.Time}, t::Dates.Time) = (t -> Dates.value(t), timeformatter)\n@recipe f(::Type{P}, t::P) where {P<:Dates.Period} =\n    (t -> Dates.value(t), t -> string(P(round(t))))","category":"page"},{"location":"generated/recipes/","page":"Default recipes","title":"Default recipes","text":"","category":"page"},{"location":"generated/recipes/#Characters","page":"Default recipes","title":"Characters","text":"","category":"section"},{"location":"generated/recipes/","page":"Default recipes","title":"Default recipes","text":"@recipe f(::Type{<:AbstractChar}, ::AbstractChar) = (string, string)","category":"page"},{"location":"generated/recipes/","page":"Default recipes","title":"Default recipes","text":"","category":"page"},{"location":"generated/recipes/","page":"Default recipes","title":"Default recipes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/plot_recipe/","page":"-","title":"-","text":"Plot Recipes","category":"page"},{"location":"generated/plot_recipe/","page":"-","title":"-","text":"@nospecialize\n\n\"\"\"\n    _process_plotrecipes!(plt, kw_list)\n\nGrab the first in line to be processed and pass it through `apply_recipe` to generate a\nlist of `RecipeData` objects.\nIf we applied a \"plot recipe\" without error, then add the returned datalist's KWs,\notherwise we just add the original KW.\n\"\"\"\nfunction _process_plotrecipes!(plt, kw_list)\n    still_to_process = kw_list\n    kw_list = KW[]\n    while !isempty(still_to_process)\n        next_kw = popfirst!(still_to_process)\n        _process_plotrecipe(plt, next_kw, kw_list, still_to_process)\n    end\n    return kw_list\nend\n\n\nfunction _process_plotrecipe(plt, kw, kw_list, still_to_process)\n    if !isa(get(kw, :seriestype, nothing), Symbol)","category":"page"},{"location":"generated/plot_recipe/","page":"-","title":"-","text":"seriestype was never set, or it's not a Symbol, so it can't be a plot recipe","category":"page"},{"location":"generated/plot_recipe/","page":"-","title":"-","text":"        push!(kw_list, kw)\n        return\n    end\n    st = kw[:seriestype]\n    st = kw[:seriestype] = type_alias(plt, st)\n    datalist = RecipesBase.apply_recipe(kw, Val{st}, plt)\n    if !isnothing(datalist)\n        warn_on_recipe_aliases!(plt, datalist, :plot, st)\n        for data in datalist\n            preprocess_attributes!(plt, data.plotattributes)\n            if data.plotattributes[:seriestype] == st\n                error(\"Plot recipe $st returned the same seriestype: $(data.plotattributes)\")\n            end\n            push!(still_to_process, data.plotattributes)\n        end\n    else\n        push!(kw_list, kw)\n    end\n    return\nend\n\n@specialize","category":"page"},{"location":"generated/plot_recipe/","page":"-","title":"-","text":"","category":"page"},{"location":"generated/plot_recipe/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/#API","page":"Public API","title":"API","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"Modules = [RecipesPipeline]\nPages = [\n  \"api.jl\"\n]\nPrivate = false","category":"page"},{"location":"api/#RecipesPipeline.get_axis_limits-Tuple{Any, Any}","page":"Public API","title":"RecipesPipeline.get_axis_limits","text":"get_axis_limits(plt, letter)\n\nGet the limits for the axis specified by letter (:x, :y or :z) in plt. If it errors, tryrange from PlotUtils is used.\n\n\n\n\n\n","category":"method"},{"location":"api/#RecipesPipeline.is_axis_attribute-Tuple{Any, Any}","page":"Public API","title":"RecipesPipeline.is_axis_attribute","text":"is_axis_attribute(plt, attr)\n\nReturns true if attr is an axis attribute, i.e. it applies to xattr, yattr and zattr, otherwise false.\n\n\n\n\n\n","category":"method"},{"location":"api/#RecipesPipeline.plot_setup!-Tuple{Any, Any, Any}","page":"Public API","title":"RecipesPipeline.plot_setup!","text":"plot_setup!(plt, plotattributes, kw_list)\n\nSetup plot, subplots and layouts. For example, Plots creates the backend figure, initializes subplots, expands extrema and links subplot axes.\n\n\n\n\n\n","category":"method"},{"location":"api/#RecipesPipeline.process_sliced_series_attributes!-Tuple{Any, Any}","page":"Public API","title":"RecipesPipeline.process_sliced_series_attributes!","text":"process_sliced_series_attributes!(plt, kw_list)\n\nAll series attributes are now properly resolved. Any change of the kw_list before the application of recipes must come here.\n\n\n\n\n\n","category":"method"},{"location":"api/#RecipesPipeline.process_userrecipe!-Tuple{Any, Any, Any}","page":"Public API","title":"RecipesPipeline.process_userrecipe!","text":"process_userrecipe!(plt, attributes_list, attributes)\n\nDo plotting package specific post-processing and add series attributes to attributeslist. For example, Plots increases the number of series in plt, sets `:seriesplotindex` in attributes and possible adds new series attributes for errorbars or smooth.\n\n\n\n\n\n","category":"method"},{"location":"api/#RecipesPipeline.slice_series_attributes!-Tuple{Any, Any, Any}","page":"Public API","title":"RecipesPipeline.slice_series_attributes!","text":"slice_series_attributes!(plt, kw_list, kw)\n\nFor attributes given as vector with one element per series, only select the value for current series.\n\n\n\n\n\n","category":"method"},{"location":"api/#RecipesPipeline.split_attribute-Tuple{Any, Any, AbstractArray, Any}","page":"Public API","title":"RecipesPipeline.split_attribute","text":"split_attribute(plt, key, val, indices)\n\nSelect the proper indices from val for attribute key.\n\n\n\n\n\n","category":"method"},{"location":"api/#RecipesPipeline.splittable_attribute-NTuple{4, Any}","page":"Public API","title":"RecipesPipeline.splittable_attribute","text":"splittable_attribute(plt, key, val, len)\n\nReturns true if the attribute key with the value val can be split into groups with group provided as a vector of length len, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#RecipesPipeline.type_alias-Tuple{Any, Any}","page":"Public API","title":"RecipesPipeline.type_alias","text":"type_alias(plt, st)\n\nReturn the seriestype alias for st.\n\n\n\n\n\n","category":"method"},{"location":"api/#Utility-functions","page":"Public API","title":"Utility functions","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"Modules = [RecipesPipeline]\nPages = [\n  \"utils.jl\"\n]","category":"page"},{"location":"api/#RecipesPipeline.Formatted","page":"Public API","title":"RecipesPipeline.Formatted","text":"Represents data values with formatting that should apply to the tick labels.\n\n\n\n\n\n","category":"type"},{"location":"api/#RecipesPipeline.Surface","page":"Public API","title":"RecipesPipeline.Surface","text":"represents a contour or surface mesh\n\n\n\n\n\n","category":"type"},{"location":"api/#RecipesPipeline.is3d-Tuple{Any}","page":"Public API","title":"RecipesPipeline.is3d","text":"is3d(::Type{Val{:myseriestype}})\n\nReturns true if myseriestype represents a 3D series, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#RecipesPipeline.is_surface-Tuple{Any}","page":"Public API","title":"RecipesPipeline.is_surface","text":"is_surface(::Type{Val{:myseriestype}})\n\nReturns true if myseriestype represents a surface series, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#RecipesPipeline.needs_3d_axes-Tuple{Any}","page":"Public API","title":"RecipesPipeline.needs_3d_axes","text":"needs_3d_axes(::Type{Val{:myseriestype}})\n\nReturns true if myseriestype needs 3d axes, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"generated/user_recipe/#User-Recipes","page":"User Recipes","title":"User Recipes","text":"","category":"section"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"\"\"\"\n    _process_userrecipes(plt, plotattributes, args)\n\nWrap input arguments in a `RecipeData' vector and recursively apply user recipes and type\nrecipes on the first element. Prepend the returned `RecipeData` vector. If an element with\nempy `args` is returned pop it from the vector, finish up, and it to vector of `Dict`s with\nprocessed series. When all arguments are processed return the series `Dict`.\n\"\"\"\nfunction _process_userrecipes!(plt, plotattributes, args)\n    @nospecialize\n    still_to_process = _recipedata_vector(plt, plotattributes, args)","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"For plotting recipes, we swap out the args and update the parameter dictionary.  We are keeping a stack of series that still need to be processed.","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"On each pass through the loop, we pop one off and apply the recipe. the recipe will return a list a Series objects. The ones that are finished (no more args) get added to the kw_list, and the ones that are not are placed on top of the stack and are then processed further.","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"    kw_list = KW[]\n    while !isempty(still_to_process)","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"grab the first in line to be processed and either add it to the kwlist or pass it through applyrecipe to generate a list of RecipeData objects (data + attributes) for further processing.","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"        next_series = popfirst!(still_to_process)","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"recipedata should be of type RecipeData. if it's not then the inputs must not have been fully processed by recipes","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"        if !(typeof(next_series) <: RecipeData)\n            error(\"Inputs couldn't be processed... expected RecipeData but got: $next_series\")\n        end\n        if isempty(next_series.args)\n            _finish_userrecipe!(plt, kw_list, next_series)\n        else\n            rd_list =\n                RecipesBase.apply_recipe(next_series.plotattributes, next_series.args...)\n                warn_on_recipe_aliases!(plt, rd_list, :user, next_series.args)\n            prepend!(still_to_process, rd_list)\n        end\n    end","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"don't allow something else to handle it","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"    plotattributes[:smooth] = false\n    kw_list\nend","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"TODO Move this to api.jl?","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"function _recipedata_vector(plt, plotattributes, args)\n    @nospecialize\n    still_to_process = RecipeData[]","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"the grouping mechanism is a recipe on a GroupBy object we simply add the GroupBy object to the front of the args list to allow the recipe to be applied","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"    if haskey(plotattributes, :group)\n        args = (_extract_group_attributes(plotattributes[:group], args...), args...)\n    end","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"if we were passed a vector/matrix of seriestypes and there's more than one row, we want to duplicate the inputs, once for each seriestype row.","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"    if !isempty(args)\n        append!(still_to_process, _expand_seriestype_array(plotattributes, args))\n    end","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"remove subplot and axis args from plotattributes... they will be passed through in the kw_list","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"    if !isempty(args)\n        for (k, v) in plotattributes\n            if is_subplot_attribute(plt, k) || is_axis_attribute(plt, k)\n                reset_kw!(plotattributes, k)\n            end\n        end\n    end\n\n    still_to_process\nend\n\nfunction _expand_seriestype_array(plotattributes, args)\n    @nospecialize\n    sts = get(plotattributes, :seriestype, :path)\n    if typeof(sts) <: AbstractArray\n        reset_kw!(plotattributes, :seriestype)\n        rd = Vector{RecipeData}(undef, size(sts, 1))\n        for r in axes(sts, 1)\n            dc = copy(plotattributes)\n            dc[:seriestype] = sts[r:r, :]\n            rd[r] = RecipeData(dc, args)\n        end\n        rd\n    else\n        RecipeData[RecipeData(copy(plotattributes), args)]\n    end\nend\n\n\nfunction _finish_userrecipe!(plt, kw_list, recipedata)","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"when the arg tuple is empty, that means there's nothing left to recursively process... finish up and add to the kw_list","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"    kw = recipedata.plotattributes\n    preprocess_attributes!(plt, kw)","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"if there was a grouping, filter the data here","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"    _filter_input_data!(kw)\n    process_userrecipe!(plt, kw_list, kw)\nend","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"","category":"page"},{"location":"generated/user_recipe/#Fallback-user-recipes","page":"User Recipes","title":"Fallback user recipes","text":"","category":"section"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"@nospecialize","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"These call _apply_type_recipe in type_recipe.jl and finally the SliceIt recipe in series.jl.","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"handle \"type recipes\" by converting inputs, and then either re-calling or slicing","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"@recipe function f(x, y, z)\n    wrap_surfaces!(plotattributes, x, y, z)\n    did_replace = false\n    newx = _apply_type_recipe(plotattributes, x, :x)\n    x === newx || (did_replace = true)\n    newy = _apply_type_recipe(plotattributes, y, :y)\n    y === newy || (did_replace = true)\n    newz = _apply_type_recipe(plotattributes, z, :z)\n    z === newz || (did_replace = true)\n    if did_replace\n        newx, newy, newz\n    else\n        SliceIt, x, y, z\n    end\nend\n@recipe function f(x, y)\n    wrap_surfaces!(plotattributes, x, y)\n    did_replace = false\n    newx = _apply_type_recipe(plotattributes, x, :x)\n    x === newx || (did_replace = true)\n    newy = _apply_type_recipe(plotattributes, y, :y)\n    y === newy || (did_replace = true)\n    if did_replace\n        newx, newy\n    else\n        SliceIt, x, y, nothing\n    end\nend\n@recipe function f(y)\n    wrap_surfaces!(plotattributes, y)\n    newy = _apply_type_recipe(plotattributes, y, :y)\n    if y !== newy\n        newy\n    else\n        SliceIt, nothing, y, nothing\n    end\nend","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"if there's more than 3 inputs, it can't be passed directly to SliceIt so we'll applytyperecipe to all of them","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"@recipe function f(v1, v2, v3, v4, vrest...)\n    did_replace = false\n    newargs = map(\n        v -> begin\n            newv = _apply_type_recipe(plotattributes, v, :unknown)\n            if newv !== v\n                did_replace = true\n            end\n            newv\n        end,\n        (v1, v2, v3, v4, vrest...),\n    )\n    if !did_replace\n        error(\"Couldn't process recipe args: $(map(typeof, (v1, v2, v3, v4, vrest...)))\")\n    end\n    newargs\nend","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"helper function to ensure relevant attributes are wrapped by Surface","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"function wrap_surfaces!(plotattributes, args...) end\nwrap_surfaces!(plotattributes, x::AMat, y::AMat, z::AMat) = wrap_surfaces!(plotattributes)\nwrap_surfaces!(plotattributes, x::AVec, y::AVec, z::AMat) = wrap_surfaces!(plotattributes)\nfunction wrap_surfaces!(plotattributes, x::AVec, y::AVec, z::Surface)\n    wrap_surfaces!(plotattributes)\nend\nfunction wrap_surfaces!(plotattributes)\n    if haskey(plotattributes, :fill_z)\n        v = plotattributes[:fill_z]\n        if !isa(v, Surface)\n            plotattributes[:fill_z] = Surface(v)\n        end\n    end\nend","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"","category":"page"},{"location":"generated/user_recipe/#Special-Cases","page":"User Recipes","title":"Special Cases","text":"","category":"section"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"1 argument","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"@recipe function f(n::Integer)\n    if is3d(plotattributes)\n        SliceIt, n, n, n\n    else\n        SliceIt, n, n, nothing\n    end\nend","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"return a surface if this is a 3d plot, otherwise let it be sliced up","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"@recipe function f(mat::AMat)\n    if is3d(plotattributes)\n        n, m = axes(mat)\n        m, n, Surface(mat)\n    else\n        nothing, mat, nothing\n    end\nend","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"if a matrix is wrapped by Formatted, do similar logic, but wrap data with Surface","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"@recipe function f(fmt::Formatted{<:AMat})\n    if is3d(plotattributes)\n        mat = fmt.data\n        n, m = axes(mat)\n        m, n, Formatted(Surface(mat), fmt.formatter)\n    else\n        nothing, fmt, nothing\n    end\nend","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"assume this is a Volume, so construct one","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"@recipe function f(vol::AbstractArray{<:MaybeNumber, 3}, args...)\n    seriestype := :volume\n    SliceIt, nothing, Volume(vol, args...), nothing\nend","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"Dicts: each entry is a data point (x,y)=(key,value)","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"@recipe function f(d::AbstractDict)\n    seriestype --> :line\n    collect(keys(d)), collect(values(d))\nend","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"function without range... use the current range of the x-axis","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"@recipe function f(f::FuncOrFuncs{F}) where {F <: Function}\n    plt = plotattributes[:plot_object]\n    xmin, xmax = if haskey(plotattributes, :xlims)\n        plotattributes[:xlims]\n    else\n        try\n            get_axis_limits(plt, :x)\n        catch\n            xinv = inverse_scale_func(get(plotattributes, :xscale, :identity))\n            xm = PlotUtils.tryrange(f, xinv.([-5, -1, 0, 0.01]))\n            xm, PlotUtils.tryrange(f, filter(x -> x > xm, xinv.([5, 1, 0.99, 0, -0.01])))\n        end\n    end\n    f, xmin, xmax\nend","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"2 arguments","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"if functions come first, just swap the order (not to be confused with parametric functions... as there would be more than one function passed in)","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"@recipe function f(f::FuncOrFuncs{F}, x) where {F <: Function}\n    F2 = typeof(x)\n    @assert !(F2 <: Function || (F2 <: AbstractArray && F2.parameters[1] <: Function))","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"otherwise we'd hit infinite recursion here","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"    x, f\nend","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"3 arguments","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"surface-like... function","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"@recipe function f(x::AVec, y::AVec, zf::Function)\n    x, y, Surface(zf, x, y)  # TODO: replace with SurfaceFunction when supported\nend","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"surface-like... matrix grid","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"@recipe function f(x::AVec, y::AVec, z::AMat)\n    if !is_surface(plotattributes)\n        plotattributes[:seriestype] = :contour\n    end\n    x, y, Surface(z)\nend","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"parametric functions special handling... xmin/xmax with parametric function(s)","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"@recipe function f(f::Function, xmin::Number, xmax::Number)\n    xscale, yscale = [get(plotattributes, sym, :identity) for sym in (:xscale, :yscale)]\n    _scaled_adapted_grid(f, xscale, yscale, xmin, xmax)\nend\n@recipe function f(fs::AbstractArray{F}, xmin::Number, xmax::Number) where {F <: Function}\n    xscale, yscale = [get(plotattributes, sym, :identity) for sym in (:xscale, :yscale)]\n    unzip(_scaled_adapted_grid.(vec(fs), xscale, yscale, xmin, xmax))\nend\n@recipe f(\n    fx::FuncOrFuncs{F},\n    fy::FuncOrFuncs{G},\n    u::AVec,\n) where {F <: Function, G <: Function} = _map_funcs(fx, u), _map_funcs(fy, u)\n@recipe f(\n    fx::FuncOrFuncs{F},\n    fy::FuncOrFuncs{G},\n    umin::Number,\n    umax::Number,\n    n = 200,\n) where {F <: Function, G <: Function} = fx, fy, range(umin, stop = umax, length = n)","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"special handling... 3D parametric function(s)","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"@recipe function f(\n    fx::FuncOrFuncs{F},\n    fy::FuncOrFuncs{G},\n    fz::FuncOrFuncs{H},\n    u::AVec,\n) where {F <: Function, G <: Function, H <: Function}\n    _map_funcs(fx, u), _map_funcs(fy, u), _map_funcs(fz, u)\nend\n@recipe function f(\n    fx::FuncOrFuncs{F},\n    fy::FuncOrFuncs{G},\n    fz::FuncOrFuncs{H},\n    umin::Number,\n    umax::Number,\n    numPoints = 200,\n) where {F <: Function, G <: Function, H <: Function}\n    fx, fy, fz, range(umin, stop = umax, length = numPoints)\nend","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"list of tuples","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"@recipe f(v::AVec{<:Tuple}) = unzip(v)\n@recipe f(tup::Tuple) = [tup]","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"list of NamedTuples","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"@recipe function f(ntv::AVec{<:NamedTuple{K, Tuple{S, T}}}) where {K, S, T}\n    xguide --> string(K[1])\n    yguide --> string(K[2])\n    return Tuple.(ntv)\nend\n@recipe function f(ntv::AVec{<:NamedTuple{K, Tuple{R, S, T}}}) where {K, R, S, T}\n    xguide --> string(K[1])\n    yguide --> string(K[2])\n    zguide --> string(K[3])\n    return Tuple.(ntv)\nend\n\n@specialize\n\nfunction _scaled_adapted_grid(f, xscale, yscale, xmin, xmax)\n    (xf, xinv), (yf, yinv) = ((scale_func(s), inverse_scale_func(s)) for s in (xscale, yscale))\n    xs, ys = PlotUtils.adapted_grid(yf ∘ f ∘ xinv, xf.((xmin, xmax)))\n    xinv.(xs), yinv.(ys)\nend","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"","category":"page"},{"location":"generated/user_recipe/","page":"User Recipes","title":"User Recipes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/group/#Grouping","page":"Grouping","title":"Grouping","text":"","category":"section"},{"location":"generated/group/","page":"Grouping","title":"Grouping","text":"\"A special type that will break up incoming data into groups, and allow for easier creation of grouped plots\"\nmutable struct GroupBy\n    group_labels::Vector                # length == numGroups\n    group_indices::Vector{Vector{Int}}  # list of indices for each group\nend","category":"page"},{"location":"generated/group/","page":"Grouping","title":"Grouping","text":"this is when given a vector-type of values to group by","category":"page"},{"location":"generated/group/","page":"Grouping","title":"Grouping","text":"function _extract_group_attributes(v::AVec, args...; legend_entry = string)\n    res = Dict{eltype(v),Vector{Int}}()\n    for (i,label) in enumerate(v)\n        if haskey(res,label)\n            push!(res[label],i)\n        else\n            res[label] = [i]\n        end\n    end\n    group_labels = sort(collect(keys(res)))\n    group_indices = [res[i] for i in group_labels]\n\n    GroupBy(map(legend_entry, group_labels), group_indices)\nend\nlegend_entry_from_tuple(ns::Tuple) = join(ns, ' ')","category":"page"},{"location":"generated/group/","page":"Grouping","title":"Grouping","text":"this is when given a tuple of vectors of values to group by","category":"page"},{"location":"generated/group/","page":"Grouping","title":"Grouping","text":"function _extract_group_attributes(vs::Tuple, args...)\n    isempty(vs) && return GroupBy([\"\"], [axes(args[1],1)])\n    v = map(tuple, vs...)\n    _extract_group_attributes(v, args...; legend_entry = legend_entry_from_tuple)\nend","category":"page"},{"location":"generated/group/","page":"Grouping","title":"Grouping","text":"allow passing NamedTuples for a named legend entry","category":"page"},{"location":"generated/group/","page":"Grouping","title":"Grouping","text":"legend_entry_from_tuple(ns::NamedTuple) =\n    join([\"$k = $v\" for (k, v) in pairs(ns)], \", \")\n\nfunction _extract_group_attributes(vs::NamedTuple, args...)\n    isempty(vs) && return GroupBy([\"\"], [axes(args[1],1)])\n    v = map(NamedTuple{keys(vs)}∘tuple, values(vs)...)\n    _extract_group_attributes(v, args...; legend_entry = legend_entry_from_tuple)\nend","category":"page"},{"location":"generated/group/","page":"Grouping","title":"Grouping","text":"expecting a mapping of \"group label\" to \"group indices\"","category":"page"},{"location":"generated/group/","page":"Grouping","title":"Grouping","text":"function _extract_group_attributes(idxmap::Dict{T,V}, args...) where {T, V<:AVec{Int}}\n    group_labels = sortedkeys(idxmap)\n    group_indices = Vector{Int}[collect(idxmap[k]) for k in group_labels]\n    GroupBy(group_labels, group_indices)\nend\n\nfilter_data(v::AVec, idxfilter::AVec{Int}) = v[idxfilter]\nfilter_data(v, idxfilter) = v\n\nfunction filter_data!(plotattributes::AKW, idxfilter)\n    for s in (:x, :y, :z)\n        plotattributes[s] = filter_data(get(plotattributes, s, nothing), idxfilter)\n    end\nend\n\nfunction _filter_input_data!(plotattributes::AKW)\n    idxfilter = pop!(plotattributes, :idxfilter, nothing)\n    if idxfilter !== nothing\n        filter_data!(plotattributes, idxfilter)\n    end\nend\n\nfunction groupedvec2mat(x_ind, x, y::AbstractArray, groupby, def_val = y[1])\n    y_mat = Array{promote_type(eltype(y), typeof(def_val))}(\n        undef,\n        length(keys(x_ind)),\n        length(groupby.group_labels),\n    )\n    fill!(y_mat, def_val)\n    for i in eachindex(groupby.group_labels)\n        xi = x[groupby.group_indices[i]]\n        yi = y[groupby.group_indices[i]]\n        y_mat[getindex.(Ref(x_ind), xi), i] = yi\n    end\n    return y_mat\nend\n\ngroupedvec2mat(x_ind, x, y::Tuple, groupby) =\n    Tuple(groupedvec2mat(x_ind, x, v, groupby) for v in y)\n\ngroup_as_matrix(t) = false","category":"page"},{"location":"generated/group/","page":"Grouping","title":"Grouping","text":"split the group into 1 series per group, and set the label and idxfilter for each","category":"page"},{"location":"generated/group/","page":"Grouping","title":"Grouping","text":"@recipe function f(groupby::GroupBy, args...)\n    plt = plotattributes[:plot_object]\n    group_length = maximum(union(groupby.group_indices...))\n    if !(group_as_matrix(args[1]))\n        for (i, glab) in enumerate(groupby.group_labels)\n            @series begin\n                label --> string(glab)\n                idxfilter --> groupby.group_indices[i]\n                for (key, val) in plotattributes\n                    if splittable_attribute(plt, key, val, group_length)\n                        :($key) := split_attribute(plt, key, val, groupby.group_indices[i])\n                    end\n                end\n                args\n            end\n        end\n    else\n        g = args[1]\n        if length(g.args) == 1\n            x = zeros(Int, group_length)\n            for indexes in groupby.group_indices\n                x[indexes] = eachindex(indexes)\n            end\n            last_args = g.args\n        else\n            x = g.args[1]\n            last_args = g.args[2:end]\n        end\n        x_u = unique(sort(x))\n        x_ind = Dict(zip(x_u, eachindex(x_u)))\n        for (key, val) in plotattributes\n            if splittable_attribute(plt, key, val, group_length)\n                :($key) := groupedvec2mat(x_ind, x, val, groupby)\n            end\n        end\n        label --> reshape(groupby.group_labels, 1, :)\n        typeof(g)((\n            x_u,\n            (groupedvec2mat(x_ind, x, arg, groupby, NaN) for arg in last_args)...,\n        ))\n    end\nend","category":"page"},{"location":"generated/group/","page":"Grouping","title":"Grouping","text":"","category":"page"},{"location":"generated/group/","page":"Grouping","title":"Grouping","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/series_recipe/#Series-Recipes","page":"Series Recipes","title":"Series Recipes","text":"","category":"section"},{"location":"generated/series_recipe/","page":"Series Recipes","title":"Series Recipes","text":"@nospecialize\n\n\"\"\"\n    _process_seriesrecipes!(plt, kw_list)\n\nRecursively apply series recipes until the backend supports the seriestype\n\"\"\"\nfunction _process_seriesrecipes!(plt, kw_list)\n    for kw in kw_list","category":"page"},{"location":"generated/series_recipe/","page":"Series Recipes","title":"Series Recipes","text":"in series attributes given as vector with one element per series, select the value for current series","category":"page"},{"location":"generated/series_recipe/","page":"Series Recipes","title":"Series Recipes","text":"        slice_series_attributes!(plt, kw_list, kw)\n    end\n    process_sliced_series_attributes!(plt, kw_list)\n    for kw in kw_list\n        series_attr = DefaultsDict(kw, series_defaults(plt))","category":"page"},{"location":"generated/series_recipe/","page":"Series Recipes","title":"Series Recipes","text":"now we have a fully specified series, with colors chosen. we must recursively handle series recipes, which dispatch on seriestype. If a backend does not natively support a seriestype, we check for a recipe that will convert that series type into one made up of lower-level components. For example, a histogram is just a bar plot with binned data, a bar plot is really a filled step plot, and a step plot is really just a path. So any backend that supports drawing a path will implicitly be able to support step, bar, and histogram plots (and any recipes that use those components).","category":"page"},{"location":"generated/series_recipe/","page":"Series Recipes","title":"Series Recipes","text":"        _process_seriesrecipe(plt, series_attr)\n    end\nend","category":"page"},{"location":"generated/series_recipe/","page":"Series Recipes","title":"Series Recipes","text":"this method recursively applies series recipes when the seriestype is not supported natively by the backend","category":"page"},{"location":"generated/series_recipe/","page":"Series Recipes","title":"Series Recipes","text":"function _process_seriesrecipe(plt, plotattributes)","category":"page"},{"location":"generated/series_recipe/","page":"Series Recipes","title":"Series Recipes","text":"replace seriestype aliases","category":"page"},{"location":"generated/series_recipe/","page":"Series Recipes","title":"Series Recipes","text":"    st = Symbol(plotattributes[:seriestype])\n    st = plotattributes[:seriestype] = type_alias(plt, st)","category":"page"},{"location":"generated/series_recipe/","page":"Series Recipes","title":"Series Recipes","text":"shapes shouldn't have fillrange set","category":"page"},{"location":"generated/series_recipe/","page":"Series Recipes","title":"Series Recipes","text":"    if plotattributes[:seriestype] == :shape\n        plotattributes[:fillrange] = nothing\n    end","category":"page"},{"location":"generated/series_recipe/","page":"Series Recipes","title":"Series Recipes","text":"if it's natively supported, finalize processing and pass along to the backend, otherwise recurse","category":"page"},{"location":"generated/series_recipe/","page":"Series Recipes","title":"Series Recipes","text":"    if is_seriestype_supported(plt, st)\n        add_series!(plt, plotattributes)\n    else","category":"page"},{"location":"generated/series_recipe/","page":"Series Recipes","title":"Series Recipes","text":"get a sub list of series for this seriestype","category":"page"},{"location":"generated/series_recipe/","page":"Series Recipes","title":"Series Recipes","text":"        x, y, z = plotattributes[:x], plotattributes[:y], plotattributes[:z]\n        datalist = RecipesBase.apply_recipe(plotattributes, Val{st}, x, y, z)\n        warn_on_recipe_aliases!(plt, datalist, :series, st)","category":"page"},{"location":"generated/series_recipe/","page":"Series Recipes","title":"Series Recipes","text":"assuming there was no error, recursively apply the series recipes","category":"page"},{"location":"generated/series_recipe/","page":"Series Recipes","title":"Series Recipes","text":"        for data in datalist\n            if isa(data, RecipeData)\n                preprocess_attributes!(plt, data.plotattributes)\n                if data.plotattributes[:seriestype] == st\n                    error(\"The seriestype didn't change in series recipe $st. This will cause a StackOverflow.\")\n                end\n                _process_seriesrecipe(plt, data.plotattributes)\n            else\n                @warn(\"Unhandled recipe: $(data)\")\n                break\n            end\n        end\n    end\n    nothing\nend\n\n@specialize","category":"page"},{"location":"generated/series_recipe/","page":"Series Recipes","title":"Series Recipes","text":"","category":"page"},{"location":"generated/series_recipe/","page":"Series Recipes","title":"Series Recipes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#RecipesPipeline.jl","page":"RecipesPipeline.jl","title":"RecipesPipeline.jl","text":"","category":"section"},{"location":"","page":"RecipesPipeline.jl","title":"RecipesPipeline.jl","text":"Documentation for RecipesPipeline.jl","category":"page"},{"location":"","page":"RecipesPipeline.jl","title":"RecipesPipeline.jl","text":"recipe_pipeline!(plt, plotattributes, args)","category":"page"},{"location":"#RecipesPipeline.recipe_pipeline!-Tuple{Any, Any, Any}","page":"RecipesPipeline.jl","title":"RecipesPipeline.recipe_pipeline!","text":"recipe_pipeline!(plt, plotattributes, args)\n\nRecursively apply user recipes, type recipes, plot recipes and series recipes to build a list of Dicts, each corresponding to a series. At the beginning, plotattributes contains only the keyword arguments passed in by the user. Then, add all series to the plot object plt and return it.\n\n\n\n\n\n","category":"method"},{"location":"recipes/#Recipes-processing","page":"Recipes","title":"Recipes processing","text":"","category":"section"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"Modules = [RecipesPipeline]\nPages = [\n  \"user_recipe.jl\",\n  \"plot_recipe.jl\",\n  \"series_recipe.jl\"\n]","category":"page"},{"location":"recipes/#RecipesPipeline._process_userrecipes!-Tuple{Any, Any, Any}","page":"Recipes","title":"RecipesPipeline._process_userrecipes!","text":"_process_userrecipes(plt, plotattributes, args)\n\nWrap input arguments in a RecipeData' vector and recursively apply user recipes and type recipes on the first element. Prepend the returnedRecipeDatavector. If an element with empyargsis returned pop it from the vector, finish up, and it to vector ofDicts with processed series. When all arguments are processed return the seriesDict`.\n\n\n\n\n\n","category":"method"},{"location":"recipes/#RecipesPipeline._process_plotrecipes!-Tuple{Any, Any}","page":"Recipes","title":"RecipesPipeline._process_plotrecipes!","text":"_process_plotrecipes!(plt, kw_list)\n\nGrab the first in line to be processed and pass it through apply_recipe to generate a list of RecipeData objects. If we applied a \"plot recipe\" without error, then add the returned datalist's KWs, otherwise we just add the original KW.\n\n\n\n\n\n","category":"method"},{"location":"recipes/#RecipesPipeline._process_seriesrecipes!-Tuple{Any, Any}","page":"Recipes","title":"RecipesPipeline._process_seriesrecipes!","text":"_process_seriesrecipes!(plt, kw_list)\n\nRecursively apply series recipes until the backend supports the seriestype\n\n\n\n\n\n","category":"method"},{"location":"generated/type_recipe/#Type-Recipes","page":"Type Recipes","title":"Type Recipes","text":"","category":"section"},{"location":"generated/type_recipe/","page":"Type Recipes","title":"Type Recipes","text":"@nospecialize","category":"page"},{"location":"generated/type_recipe/","page":"Type Recipes","title":"Type Recipes","text":"this is the default \"type recipe\"... just pass the object through","category":"page"},{"location":"generated/type_recipe/","page":"Type Recipes","title":"Type Recipes","text":"@recipe f(::Type{T}, v::T) where {T} = v","category":"page"},{"location":"generated/type_recipe/","page":"Type Recipes","title":"Type Recipes","text":"this should catch unhandled \"series recipes\" and error with a nice message","category":"page"},{"location":"generated/type_recipe/","page":"Type Recipes","title":"Type Recipes","text":"@recipe f(::Type{V}, x, y, z) where {V <: Val} =\n    error(\"The backend must not support the series type $V, and there isn't a series recipe defined.\")\n\n\"\"\"\n    _apply_type_recipe(plotattributes, v::T, letter)\n\nApply the type recipe with signature `(::Type{T}, ::T)`.\n\"\"\"\nfunction _apply_type_recipe(plotattributes, v, letter)\n    plt = plotattributes[:plot_object]\n    preprocess_axis_args!(plt, plotattributes, letter)\n    rdvec = RecipesBase.apply_recipe(plotattributes, typeof(v), v)\n    warn_on_recipe_aliases!(plotattributes[:plot_object], plotattributes, :type, v)\n    postprocess_axis_args!(plt, plotattributes, letter)\n    return rdvec[1].args[1]\nend","category":"page"},{"location":"generated/type_recipe/","page":"Type Recipes","title":"Type Recipes","text":"Handle type recipes when the recipe is defined on the elements. This sort of recipe should return a pair of functions... one to convert to number, and one to format tick values.","category":"page"},{"location":"generated/type_recipe/","page":"Type Recipes","title":"Type Recipes","text":"function _apply_type_recipe(plotattributes, v::AbstractArray, letter)\n    plt = plotattributes[:plot_object]\n    preprocess_axis_args!(plt, plotattributes, letter)","category":"page"},{"location":"generated/type_recipe/","page":"Type Recipes","title":"Type Recipes","text":"First we try to apply an array type recipe.","category":"page"},{"location":"generated/type_recipe/","page":"Type Recipes","title":"Type Recipes","text":"    w = RecipesBase.apply_recipe(plotattributes, typeof(v), v)[1].args[1]\n    warn_on_recipe_aliases!(plt, plotattributes, :type, v)","category":"page"},{"location":"generated/type_recipe/","page":"Type Recipes","title":"Type Recipes","text":"If the type did not change try it element-wise","category":"page"},{"location":"generated/type_recipe/","page":"Type Recipes","title":"Type Recipes","text":"    if typeof(v) == typeof(w)\n        isempty(skipmissing(v)) && return Float64[]\n        x = first(skipmissing(v))\n        args = RecipesBase.apply_recipe(plotattributes, typeof(x), x)[1].args\n        warn_on_recipe_aliases!(plt, plotattributes, :type, x)\n        postprocess_axis_args!(plt, plotattributes, letter)\n        if length(args) == 2 && all(arg -> arg isa Function, args)\n            numfunc, formatter = args\n            return Formatted(map(numfunc, v), formatter)\n        else\n            return v\n        end\n    end\n    postprocess_axis_args!(plt, plotattributes, letter)\n    return w\nend","category":"page"},{"location":"generated/type_recipe/","page":"Type Recipes","title":"Type Recipes","text":"special handling for Surface... need to properly unwrap and re-wrap","category":"page"},{"location":"generated/type_recipe/","page":"Type Recipes","title":"Type Recipes","text":"_apply_type_recipe(\n    plotattributes,\n    v::Surface{<:AMat{<:Union{AbstractFloat, Integer, AbstractString, Missing}}},\n    letter,\n) = v\nfunction _apply_type_recipe(plotattributes, v::Surface, letter)\n    ret = _apply_type_recipe(plotattributes, v.surf, letter)\n    if typeof(ret) <: Formatted\n        Formatted(Surface(ret.data), ret.formatter)\n    else\n        Surface(ret)\n    end\nend","category":"page"},{"location":"generated/type_recipe/","page":"Type Recipes","title":"Type Recipes","text":"don't do anything for datapoints or nothing","category":"page"},{"location":"generated/type_recipe/","page":"Type Recipes","title":"Type Recipes","text":"_apply_type_recipe(\n    plotattributes,\n    v::AbstractArray{<:Union{AbstractFloat, Integer, AbstractString, Missing}},\n    letter,\n) = v\n_apply_type_recipe(plotattributes, v::Nothing, letter) = v\n\n@specialize","category":"page"},{"location":"generated/type_recipe/","page":"Type Recipes","title":"Type Recipes","text":"","category":"page"},{"location":"generated/type_recipe/","page":"Type Recipes","title":"Type Recipes","text":"This page was generated using Literate.jl.","category":"page"}]
}
